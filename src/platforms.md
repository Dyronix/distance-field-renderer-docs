# Platforms
---

When it comes to AM, visualisation of our to-be-printed model should be available to an end-user. PortaPivot has an editor to customise products to the customers' needs. This example allows the end-user more control over the products they order while also eliminating the need for a professional salesperson to interact with an in-house application.

Besides the PortaPivot editor, which runs in a web browser, multiple applications have received a port to different platforms as other libraries have been designed [55 – 57] to abstract the boilerplate required to implement the foundation of these types of applications. These abstractions cover numerous systems such as creating a window, graphics API, input devices, audio system, virtual file system, etc. They allow for one solution that needs to be maintained instead of conditionally compiled code that takes different platforms into account. This can reduce development time, and complex cross-platform frameworks can be made easier to use. 

The following section (2.5.1) will go over several useful libraries that go over these abstractions in depth. Section 2.5.2 will go through specific graphics APIs in greater detail and the benefits they may provide to our project.

## Cross Platform Libraries

The Open Graphics Framework (GLFW) (version 3.3.5) is a lightweight utility library for use with OpenGL / OpenGL ES and Vulkan. Other APIs are possible with GLFW. However, GLFW provides a platform-independent API; adding support for Diret3D would stop support for platforms other than Microsoft products (e.g., Windows and Xbox). It supports creating new windows, handling user input with a mouse and keyboard or the gamepad, and high Dots Per Inch (DPI). As the target platform for this framework aims at desktop applications, the support for touch input is limited. However, a different branch on the official GitHub repository handles touch. 

Qt (version 6.2), a widget toolkit, appears to be the optimal solution when a development team starts production on an application. It supports Linux, Windows, macOS, Android, or embedded systems. However, Qt’s feature-set is too rich for what we are trying to achieve as it would add unnecessary overhead to a prototype. This overhead might influence the performance measurements of the application. 

Our Machinery (version 1.0) is a new tool on the market that will give a development team control of which part of the framework to use and which parts to discard by using plugins. Although the technology and demonstrations seem very intriguing, there is no web support at the moment of writing. We could strip down the already present Vulkan renderer and implement our own OpenGL / OpenGL ES context, but this would require more research to investigate how we could optimally implement this while other solutions are available. A future research project might explore this path to compare results with what we achieved in this thesis.

SDL (version 2.0.16) is a library written in C, designed to provide low-level audio, input devices, and graphics access. SDL officially supports Windows, macOS, Linux, iOS, and Android. SDL can specify modules during initialisation, reducing the runtime overhead of specific parts of the code that we do not require. 

## Graphics API

Enabling support on different platforms for 3D applications yields support for multiple graphical APIs (e.g., Metal on macOS or Direct3D on Windows). As mentioned, these APIs keep the programmer away from writing code to manipulate graphics hardware accelerators. Using one of the libraries discussed in section 2.5.1 enables the support of different graphical APIs, allowing the use of these frameworks across different platforms. 

Because graphics card manufacturers (e.g., Nvidia ®, AMD)  must provide an implemented OpenGL interface in order to ship a graphics card, combining OpenGL with a cross-platform windowing library could target different systems with a single software solution. However, Apple deprecated OpenGL in 2018 and recommended developers to adopt their Metal API instead if they wanted to leverage hardware acceleration on macOS, making OpenGL as a platform-independent API obsolete. As a result of the deprecation of OpenGL. In 2014, the Kronos Group began work on Vulkan (derived from the original Mantle design made by AMD and DICE), formerly known as glNext. Vulkan is a low-overhead cross-platform API and open standard for 3D graphics and computing. In 2016, the Vulkan Software Development Kit (SDK) was given to the public, making the Vulkan standard open-source. However, like OpenGL, there is no support for Vulkan on macOS. Due to this reason, MoltenVK was created as a collaboration between The Brenwill Workshop Ltd and The Kronos Group. MoltenVK is a software library that allows Vulkan programs to run on top of Metal on Apple’s macOS, iOS, and tvOS operating systems. It is the first piece of software released as part of the Vulkan Portability Initiative, which seeks to make a portion of Vulkan run on devices that do not have native Vulkan drivers. Make a note of the various drawbacks when compared to a native Vulkan API 

Unfortunately, using Vulkan would only cover a subset of mobile devices, and there is no Vulkan API available for web browsers. Nevertheless, in 2011, The Khronos Group released the first version of WebGL™. WebGL™ is a JavaScript API for rendering high-performance interactive 3D and 2D graphics within any compatible web browser without plugins. WebGL™ does so by introducing an API related to OpenGL ES (OpenGL for embedded systems) that can be used in an HTML5 canvas. With the introduction of WebGL™, The Kronos Group made it possible for the API to take advantage of hardware acceleration provided by the user’s device. The shader language within WebGL™ is a subset of GLSL, equipped with similar syntax as the OpenGL ES API. 

Because OpenGL is a global state machine, it has struggled to gain traction as a graphics API in the graphics industry. A global state machine is unstable in software development because anything within the program (including third-party libraries) can affect the state of our program. Because everyone in the code-base has direct access to data, it breaches encapsulation. It is tough to make changes since dependencies throughout the code-base necessitate an API update. Dependency injection and class encapsulation have been proposed as alternatives to the global state system.

As OpenGL faltered, so did WebGL, necessitating the development of a next-generation web API. In September 2021, a 1.0 version of WebGPU was made available to the public. WebGPU is a successor to WebGL, even though WebGL is not going anywhere soon because there is more support for WebGL than for WebGPU. The hope is to fade out WebGL and use WebGPU to replace this legacy API. WebGPU will introduce a new shading language called WGLSL. This shading language is convertible to SPIR-V, a binary intermediate language for graphical shaders and compute kernels. WebGPU was created with the DirectX 12 and Vulkan APIs in mind to eliminate the global state present in OpenGL and move toward an Object-Oriented (OO) API. This object-oriented mindset will provide a more solid foundation for new additions. As with DirectX 12 or Vulkan, WebGPU is a Hardware Abstraction Layer (HAL). Libraries like dawn (chromium browsers), wgpu-native (firefox), and emscripten (web assembly) already implement this layer. WebGPU’s path looks bright, with multithreading functionality set to be released in 2022 and raytracing and mesh shader implementations expected to follow.
