# Chapter 3: Reseach Methodology
---

This research aims to understand the effect of signed distance fields when rendering complex structures within a web-based environment. Within the context of this thesis, we consider a lattice a complex structure. To reach this goal, we focus on the following question:

Q1: How do evaluations of distances towards the surface of complex structures compare to traditional triangle rasterisation of complex structures?

First, we can use deferred rendering to render different sets of geometry on the screen using a standard triangle rasterisation method. [Appendix A.3] contains more information on deferred rendering and how one can achieve a deferred renderer. Rendering our geometry using a rasteriser will serve as a baseline when comparing it to the measurements of the distance field renderer. We will explore different parameters that we will elaborate on in chapter 4 to evaluate the performance of both rendering techniques in those scenarios. Both rendering techniques will be evaluated in each step to see how they compare to one another. This process should be repeated for each new step that has been investigated.

Comparison between renderers is possible because both systems require a preprocessed input step, also known as a G-buffer, to reach a final render. The G-buffer is used to shade each pixel with relevant lighting values. Light calculations are often the most expensive part of the rendering pipeline. Deferring our light calculations prevents them from being calculated more than once, as overdraw can be eliminated. The G-Buffer within the context of our distance field renderer is calculated by tracing against our distance field with an algorithm called sphere tracing.  Sphere tracing will find the surface of a geometric figure using a custom-made distance function designed for the given type of geometry. The resulting data such as surface positions, normals, albedo, and specular values can be stored within the G-buffer. The findings of our experiment may be used to establish the most influential parameters in this step, as well as which solution can be used to compute the final render optimally. 

The performance of both rasterisation and distance field rendering will also be measured at the initialisation stage of the application. The initialisation stage will start loading and compiling the shaders required to create the G-Buffer and load the input mesh or volume we want to render. These application steps must be measured because they may influence which scenario is chosen over the other. These measurements will be logged in microseconds but displayed in milliseconds for readability. To determine the significant bottlenecks inside the renderer and the initialisation stage, we will employ separate modules for each section that makes up our prototype. We can use our instrumentor to find and analyse why these bottlenecks might occur.

Even though we can test an application’s performance on any device, we believe that different platforms, such as mobile phones, tablets, laptops, and desktops, would produce inconsistent results when compared. We would also like to point out some of the study’s limitations, such as the fact that comparing other platforms would necessitate more research, which would be impossible to complete in a year’s time. As a result, we will run the performance tests on a single device that we consider “current-gen” and capable of assessing our methods. The hardware specifications of this device can be found in chapter 4.1.

In the upcoming sections, we will explain how our prototype will be structured and help us measure critical aspects that might influence the performance of our experiment. The prototype will be divided into two phases: online and offline. The online phase of this experiment will be measured using a distance field and compared to traditional methods. The offline phase will cover how we supply content to our experiment, which is not covered in this thesis.
